**Лабораторная работа №15**

Колосова Кристина Александровна

# **Цель работы**

Приобретение практических навыков работы с именованными каналами.

# **Выполнение лабораторной работы**

Для передачи данных между неродственными процессами можно использовать механизм именованных каналов (named pipes). Данные передаются по принципу FIFO 
(First In First Out)

Файлы именованных каналов создаются функцией mkfifo

int mkfifo(const char *pathname, mode_t mode);

Первый параметр — имя файла, идентифицирующего канал, второй параметр — маска прав доступа к файлу. 

После создания файла канала процессы, участвующие в обмене данными, должны открыть этот файл либо для записи, либо для чтения. 
При закрытии файла сам канал продолжает существовать. Для того чтобы закрыть сам канал, нужно удалить его файл, например с помощью вызова unlink

Каналы представляют собой простое и удобное средство передачи данных, которое, однако, подходит не во всех ситуациях. Например, с помощью каналов 
довольно трудно организовать обмен асинхронными сообщениями между процессами.

Изучила приведённые в тексте программы server.c и client.c. Взяв данные примеры за образец, написала аналогичные программы (рис. - @fig:001)
(рис. - @fig:002)(рис. - @fig:003), внеся следующие изменения:

1)	Работает не 1 клиент, а несколько (например, два). 

2)	Клиенты передают текущее время с некоторой периодичностью (например, раз в пять секунд). Используйте функцию sleep() для приостановки работы клиента. 

3)	Сервер работает не бесконечно, а прекращает работу через некоторое время (например, 30 сек). Используйте функцию clock() для определения времени 
работы сервера. 

![Рис. 1. Файл common.h](image15/p1.jpg)

{#fig:001 width=100%}
 
![Рис. 2. Файл server.c](image15/p2.jpg)

{#fig:002 width=100%}
 
![Рис. 3. Файл client.c](image15/p1.jpg)

{#fig:003 width=100%}


Результат: (рис. - @fig:004)(рис. - @fig:005) 
 
![Рис. 4. Вызов server](image15/p4.jpg)

{#fig:004 width=100%}
 
![Рис. 5. Вызов client](image15/p5.jpg)

{#fig:005 width=100%}

Что будет в случае, если сервер завершит работу, не закрыв канал?

- при закрытии сервера до закрытия каналов ничего не произошло - они автоматчики закрываются при завершении программы. Но закрывать их необходимо.
 Если этого не делать – некорректное завершение приведет к проблемам.

# **Выводы**

Приобрела практические навыки работы с именованными каналами.

# **Библиография**

c - make: Nothing to be done for `all' - Stack Overflow

c - Sleep | warning implicit declaration of function `sleep'? - Stack Overflow

Что такое каналы (pipe) в Linux? Как работает перенаправление каналов? (andreyex.ru)




